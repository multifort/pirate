#
# Redis Cluster service
#
apiVersion: v1
kind: List
items: 
- apiVersion: v1
  kind: Service
  metadata:
    annotations:
      service.alpha.kubernetes.io/tolerate-unready-endpoints: "false"
    name: ${NAME}-cluster
    <% if(APPLICATION_NAME != null) { %>
    namespace: application-${APPLICATION_NAME}
    labels: 
      app: ${APPLICATION_NAME}
    <% } else { %>
    namespace: application-store
    <% } %>
  spec:
    <% if(NODE_TYPE != null){ %>
    type: NodePort
    <% } %>
    ports:
      <% if(ports != null){ %> 
      <% for(port in ports){ %>
      - port: ${port.port}
        nodePort: ${port.nodePort}
        targetPort: ${port.targetPort}
        protocol: ${port.protocol}
        name: http-${port.targetPort}
      <% } %>
      <% } %>
      <% if(nodePorts != null){ %>   
      <% for(port in nodePorts){ %>
      - port: ${port.port}
        targetPort: ${port.targetPort}
        protocol: ${port.protocol}
        name: http-${port.targetPort}
      <% } %>
      <% } %>
      <% for(var i = 0; i < containerPorts.~size; i++){ %>
      - port: ${containerPorts[i].key}
        targetPort: ${containerPorts[i].key}
        protocol: ${containerPorts[i].value}
        name: http-${i}
      <% } %>
    #type: ClusterIP
    selector:
      name: ${NAME}-cluster

#
# Redis configuration file for clustered mode
#
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: ${NAME}-cluster-config
    <% if(APPLICATION_NAME != null) { %>
    namespace: application-${APPLICATION_NAME}
    <% } else { %>
    namespace: application-store
    <% } %>
  data:
    redis.conf: |+
      cluster-enabled yes
      cluster-require-full-coverage no
      cluster-node-timeout 15000
      cluster-config-file nodes.conf
      cluster-migration-barrier 1 
      appendonly yes
      # Other cluster members need to be able to connect
      protected-mode no

    bootstrap-pod.sh: |+
      #!/bin/sh
      set -e
  
      # Find which member of the Stateful Set this pod is running
      # e.g. "redis-cluster-0" -> "0"
      PET_ORDINAL=$(cat /etc/podinfo/pod_name | rev | cut -d- -f1)
  
      redis-server /conf/redis.conf &
      # Discover peers
      wget https://storage.googleapis.com/kubernetes-release/pets/peer-finder -O /bin/peer-finder
      chmod u+x /bin/peer-finder
      peer-finder -on-start 'tee > /conf/initial_peers' -service redis-cluster -ns $POD_NAMESPACE
  
      # TODO: Wait until redis-server process is ready
      sleep 1
  
      if [ $PET_ORDINAL = "0" ]; then
        # The first member of the cluster should control all slots initially
        redis-cli cluster addslots $(seq 0 16383)
      else
        # Other members of the cluster join as slaves
        # TODO: Get list of peers using the peer finder using an init container
        <% if(APPLICATION_NAME != null) { %>
        PEER_IP=$(perl -MSocket -e 'print inet_ntoa(scalar(gethostbyname("${NAME}-cluster-0.${NAME}-cluster.application-${APPLICATION_NAME}.svc.cluster.local")))')
        <% } else { %>
        PEER_IP=$(perl -MSocket -e 'print inet_ntoa(scalar(gethostbyname("${NAME}-cluster-0.${NAME}-cluster.application-store.svc.cluster.local")))')
        <% } %>
        redis-cli cluster meet $PEER_IP 6379
        sleep 1
  
        #echo redis-cli --csv cluster slots
        #redis-cli --csv cluster slots
  
        # Become the slave of a random master node
        MASTER_ID=$(redis-cli --csv cluster slots | cut -d, -f 5 | sed -e 's/^"//'  -e 's/"$//')
        redis-cli cluster replicate $MASTER_ID
      fi
  
      wait

- apiVersion: apps/v1beta1
  kind: StatefulSet
  metadata:
    name: ${NAME}-cluster
    <% if(APPLICATION_NAME != null) { %>
    namespace: application-${APPLICATION_NAME}
    <% } else { %>
    namespace: application-store
    <% } %>
  spec:
    serviceName: ${NAME}-cluster
    replicas: 6
    template:
      metadata:
        labels:
          name: ${NAME}-cluster
        annotations:
          # NOTE: Init container must be idempotent
          # Add a baked-in Redis config file that enables cluster mode
          #pod.alpha.kubernetes.io/init-containers: '[
          #]'
      spec:
        terminationGracePeriodSeconds: 10
        #hostNetwork: true
        containers:
        - name: ${NAME}-cluster
          image: 139.219.239.226/library/redis:3.2.1
          resources:
            limits:
              <% if (LIMITS_CPU != null) { %>
              cpu: ${LIMITS_CPU}
              <% } %>
              <% if (LIMITS_MEMORY != null) { %>
              memory: ${LIMITS_MEMORY}
              <% } %>
            requests:
              <% if (REQUESTS_CPU != null) { %>
              cpu: ${REQUESTS_CPU}
              <% } %>
              <% if (REQUESTS_MEMORY != null) { %>
              memory: ${REQUESTS_MEMORY}
              <% } %>
          ports:
          - containerPort: 6379
            name: client
          - containerPort: 16379
            name: gossip
          command:
          - sh
          args:
          - /conf/bootstrap-pod.sh
          # Ensure that Redis is online before initializing the next node.
          # TODO: Test that the cluster node is init'd properly.
          readinessProbe:
            exec:
              command:
              - sh
              - -c
              - "redis-cli -h $(hostname) ping"
            initialDelaySeconds: 15
            timeoutSeconds: 5
  
          # Mark a node as down if Redis server stops running
          livenessProbe:
            exec:
              command:
              - sh
              - -c
              - "redis-cli -h $(hostname) ping"
            initialDelaySeconds: 20
            periodSeconds: 3
          env:
          - name: POD_NAMESPACE
            valueFrom:
              fieldRef:
                fieldPath: metadata.namespace
          volumeMounts:
          - name: conf
            mountPath: /conf
            readOnly: false
          - name: podinfo
            mountPath: /etc/podinfo
            readOnly: false
        volumes:
        # Insert our pre-baked Redis configuration file into /conf/redis.conf
        - name: conf
          configMap:
            name: ${NAME}-cluster-config
            items: 
            - key: redis.conf
              path: redis.conf
            - key: bootstrap-pod.sh  # TODO: Move this or extract it into its own Docker image
              path: bootstrap-pod.sh
        # The init container will use this info to find cluster peers
        - name: podinfo
          downwardAPI:
            items:
              - path: "labels"
                fieldRef:
                  fieldPath: metadata.labels
              - path: "annotations"
                fieldRef:
                  fieldPath: metadata.annotations
              - path: "pod_name"
                fieldRef:
                  fieldPath: metadata.name
              - path: "pod_namespace"
                fieldRef:
                  fieldPath: metadata.namespace

{"parameters":
  [
    {
      "description": "组件名称",
      "displayName": "名称",
      "name": "NAME",
      "value": "",
      "select": "",
      "type": "String",
      "required": "true"
    },
    {
      "description": "资源配置",
      "displayName": "修改资源会重新启动所有该组件下的实例",
      "name": "RESOURCE",
      "value": "",
      "select": "",
      "type": "Resource",
      "required": "false"
    },
    {
      "description": "端口信息",
      "displayName": "端口信息",
      "name": "PORT",
      "value": "",
      "select": "",
      "type": "Ports",
      "required": "false"
    }
  ]}